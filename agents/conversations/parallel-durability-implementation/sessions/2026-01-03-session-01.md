# Parallel Durability Implementation - Session 1

**Date**: 2026-01-03
**Focus**: Making parallel execution truly durable and resumable
**Status**: completed

## Summary

Implemented true durability for parallel steps in the Durable workflow engine. Previously, when a workflow with parallel steps was resumed, all parallel steps would re-execute even if they had already completed. This session fixed that behavior by storing context snapshots with parallel step outputs and checking for completed steps before execution.

## Key Decisions

- **Context Snapshot Storage**: Store the full context snapshot in a `__context__` key alongside the `__output__` for parallel steps. This enables proper context merging on resume.
- **Stored Output Structure**: Parallel step outputs are stored as `%{"__output__" => serialized_output, "__context__" => context_snapshot}` to preserve both the return value and accumulated context.
- **Sequential Features Over Nested**: Rather than implementing parallel/foreach inside branch clauses, use features sequentially. Nested support deferred to future work.
- **Converging Step Pattern**: When using `decision` with `{:goto, :step_name}`, use a converging "finalize" step that checks context to handle both paths cleanly.

## Problem Statement

When a workflow with parallel steps was paused (e.g., waiting for input) and later resumed, all parallel steps would re-execute regardless of completion status. This caused:
- Duplicate side effects
- Wasted computation
- Incorrect behavior for non-idempotent operations

## Solution Architecture

### 1. Step Runner Modifications (`lib/durable/executor/step_runner.ex`)

Modified `handle_step_result/6` to detect parallel steps and store context alongside output:

```elixir
defp handle_step_result(repo, step, step_exec, output, logs, duration_ms) do
  stored_output =
    if step.opts[:parallel_id] do
      # Include context snapshot so we can restore it on resume
      %{
        "__output__" => serialize_output(output),
        "__context__" => Context.get_current_context()
      }
    else
      output
    end
  {:ok, _} = complete_step_execution(repo, step_exec, stored_output, logs, duration_ms)
  {:ok, output}
end
```

### 2. Executor Modifications (`lib/durable/executor.ex`)

Added `get_completed_parallel_steps_with_context/3` function that:
- Queries completed `StepExecution` records for parallel steps
- Extracts stored contexts from `output["__context__"]`
- Returns both completed step names and their contexts for merging

The parallel execution flow now:
1. Checks for already-completed parallel steps
2. Skips execution of completed steps
3. Merges their stored contexts into the current context
4. Only executes remaining incomplete steps

## Integration Tests Created

Created comprehensive integration tests in `test/durable/integration_test.exs` covering:

1. **E-Commerce Order Processing** (Branch -> ForEach -> Parallel)
   - Physical vs digital order routing via branch
   - ForEach processing of line items
   - Parallel notification tasks

2. **Document Approval** (Decision/goto -> Parallel -> Branch -> ForEach)
   - Auto-approval path (decision jumps to finalize)
   - Manual approval with parallel notifications
   - Approved vs rejected branch routing

3. **Batch Data Migration** (ForEach -> Decision -> Parallel)
   - Batch processing with foreach
   - Empty batches taking decision's goto path
   - Parallel reporting tasks

4. **Resume Durability** (Parallel step resume behavior)
   - Verifies completed parallel steps are NOT re-executed on resume
   - Verifies context is properly merged from stored snapshots

## Feature Limitation Discovered

Parallel and foreach inside branch clauses is NOT supported. Investigation revealed:
- `extract_step_call/3` in `lib/durable/dsl/step.ex` only handles `:step` atoms
- `:parallel` and `:foreach` are silently ignored in branch extraction
- **Decision**: Use features sequentially rather than nesting them

## Bug Fix: Decision/Goto Converging Pattern

**Issue**: When using `{:goto, :step_name}`, placing the target step at the end of the workflow caused both paths to execute it.

**Solution**: Use a converging "finalize" step that checks context:

```elixir
step :finalize do
  if !has_context?(:migration_status) do
    put_context(:migration_status, "empty")  # Jumped here directly
  end
  put_context(:completed_at, true)
end
```

This ensures both paths converge cleanly with appropriate context values.

## Action Items

- [x] Modify step_runner.ex to store context snapshot for parallel steps
- [x] Modify executor.ex to check for completed parallel steps before execution
- [x] Merge stored contexts when resuming with completed parallel steps
- [x] Create integration tests covering Branch, ForEach, Parallel, Decision combinations
- [x] Verify all 117 tests pass
- [ ] (Future) Add support for parallel/foreach inside branch clauses

## Open Questions

- Should we add a configuration option to disable context snapshot storage for memory-constrained environments?
- Should there be a cleanup mechanism for old context snapshots to prevent bloat?

## Key Files

- `lib/durable/executor.ex` - Parallel execution with resume logic
- `lib/durable/executor/step_runner.ex` - Context snapshot storage
- `test/durable/integration_test.exs` - 11 integration tests
- `test/durable/parallel_test.exs` - Parallel-specific tests

---
*Archived by conversation-archiver agent*
